みなさん、こんにちは！
さて、この連載も今回で最後になってしまいました。
最後の記事では非常になじみのある「null」について考え直してみたいと思います。

そもそもnullってなんでしょうか？
おおざっぱに言えば「何もない」ことを表す特別な値です。
多くの言語では初期化されていない変数の初期値に利用されたりします。
ところが、このnull、実は各言語によってかなり扱い方がことなります。
そこで各言語でのnull扱いを眺めながら、nullとはどういうものだったかを考えてみましょう。

まずはC言語から。
C言語でNULLというと、何も指していない特別なポインタの意味で利用されます。
C言語のポインタはメモリのアドレスを表すため、NULLは無効なメモリアドレスを表すことになります。
アドレスなので、NULLは値を持ちます。またint型の変数としても扱えます（アドレスなので）
以下のようなコードを書いて実際の値を確認することもできます。

#include <stdio.h>

int main(void){
  int i=NULL;
  printf("%d\n",i);
  return 0;
}

ほとんどのCコンパイラではこの値を0としています。
（仕様で0とされているわけではなく、たまたまほとんどのCコンパイラが0にしているだけなので、NULLを0だと思い込むことは危険です）
また、NULLはアドレスを表すので、NULL領域を読み書きすることも可能です。
ただし、動作が保証されない非常に危険なコードになってしまいます。
というわけでC言語ではNULLは「何もない」ことを表すというよりは、「何もないことを表すためのは特別なメモリアドレス」だと覚えても構わないでしょう。


これに対して、Javaでは事情が異なります。まずJavaにはポインタという概念がありません。
ですので、JavaのnullはC言語とはそもそも異なる考え方になります。
何が変わるかというと、Javaではポインタの代わりに参照という考え方を採用しているため
null自体もポインタではなくなっています。
参照はポインタと似ていますが、実際のメモリアドレスを表すというわけではありません。
例えば

Usagi usagi = new Usagi('ウーちゃん');

と書くと、「new Usagi('ウーちゃん')」の具体的な値がJavaのヒープメモリ上に展開されます。
この値（オブジェクト）にアクセスするためには、メモリアドレスを知る必要があるのですが、
Javaではメモリアドレスは隠蔽されますので、ユーザはこのオブジェクトのアドレスを知ることができません。
Javaはこのオブジェクトのアドレスを直接渡すのではなく、参照という別の形にしてユーザにわたします。
その参照を格納するのが、「usagi」という変数になります。
で、実際にオブジェクトにアクセスするには

usagi.jump();

のように、参照を通じてオブジェクトにアクセスします。
そしてJVMが参照から実際のメモリアドレスのアクセスを行ってくれます。
つまり、C言語のポインタがメモリのアドレスを直接示していたのに対して
Javaの参照は直接メモリを示す代わりにオブジェクトのアドレスに変換できるJVM上の特別な値になります。
このため、C言語の場合、ポインタは数値として表現できますが、参照をどう表現するかはJVMの自由になります。

このため、Javaのnullは非常に特別な値として扱われます。
Javaではnullは指し示すオブジェクトが存在しないことを表す特別な参照値になりますが
C言語のようにnullをint型に変換することはできません。
そもそも参照値はユーザから隠されているので、参照をintのように具体的な値に変換することはできません。



