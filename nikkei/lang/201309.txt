みなさん、こんにちは！
さて、この連載も今回で最後になってしまいました。
最後の記事では非常になじみのある「null」について考え直してみたいと思います。

そもそもnullってなんでしょうか？
おおざっぱに言えば「何もない」ことを表す特別な値です。
ではnullをどう利用するのかというと、これには大きく2つの利用方法があります。
まず、関数の結果として「何もない」ことを表すデータとしてnullが利用され
また、変数の初期値に用いられる場合の2点があります。
例えば、データの集合から何かのデータを取得する場合を考えましょう。

usagi = rabbits.getByName("ウーちゃん")

のコードの場合rabbitsというウサギの集合から、ウーちゃんという名前のうさぎを取り出しています。
rabbitsの中に「ウーちゃん」がいれば問題ないですが、もし「ウーちゃん」がいない場合どうするべきかという問題があるわけです。
ここで「そんなウサギはいませんよ」ということを表すためにnullを使うわけです。
また、変数の初期値にnullを入れることで、「まだちゃんと初期化されてませんよ」ということを表現したりします。

多くの言語でnullはこのような使われ方がされます。
しかし、詳細にみると実は各言語によってかなり扱い方がことなります。
そこで各言語でのnull扱いを眺めながら、nullとはどういうものだったかを考えてみましょう。

まずはC言語から。
C言語でNULLというと、何も指していない特別なポインタの意味で利用されます。
C言語のポインタはメモリのアドレスを表すため、NULLは無効なメモリアドレスを表すことになります。
アドレスなので、NULLは値を持ちます。また数値としても扱えます（アドレスなので）
以下のようなコードを書いて実際の値を確認することもできます。

#include <stdio.h>

int main(void){
  int i=NULL;
  printf("%d\n",i);
  return 0;
}

ほとんどのCコンパイラではこの値を0としています。
（仕様で0とされているわけではなく、たまたまほとんどのCコンパイラが0にしているだけなので、NULLを0だと思い込むことは危険です）
また、NULLはアドレスを表すので、NULL領域を読み書きすることも可能です。
ただし、動作が保証されない非常に危険なコードになってしまいます。
というわけでC言語ではNULLは「何もない」ことを表すというよりは、「何もないことを表すためのはメモリアドレス」だと覚えても構わないでしょう。

C言語のNULLにはいくつかの問題が存在します。
さきほど見たように、C言語のNULLは、言語が提供する特別な値でもなんでもなく、ただの数値です。
「NULLの値を特別な値として扱いましょうね」というお約束が存在するに過ぎず、プログラマが絶対的に従う必要がないのです。
例えば、メモリを確保するために以下のコードを実行したとしましょう。

int* arr = (int*)malloc(sizeof(int)*100);

このメモリ確保に失敗した場合、arrにはNULLが入ることになります。
しかし、NULLは普通のアドレス値としても扱えるため、メモリ確保に失敗したことに気づかずにそのまま処理を続行させることができます。
これはとても危険です。

また別の問題点としては、C言語の変数の初期化の方法です。
nullは変数の初期値に使われると書きましたが、C言語では、言語側が変数をNULLで初期化してくれるわけではありません。
NULLで初期化するかどうかはプログラマの責任です。
これも、NULLはただの数値であって、言語として特別な扱いをしているわけではないからですね。


これに対して、Javaでは事情が異なります。JavaはC言語のこのような反省の上に成り立っており、
Javaのnullは言語が提供する特別な値になっています。
まず全てのオブジェクト型の変数（フィールド含む）の初期値はnullになっています。
このためあるフィールドが初期化されているかどうかを判断するにはnull値になっていないかどうかをチェックすれば分かります。
また、nullを利用しようとするとエラーが発生するようになっているため
間違ったまま処理が続くという危険性も低くなります。

usagi = rabbits.getByName("ウーちゃん");
usagi.jump();

というコードで、usagiにnullが入っていると必ず例外が発生すようになっています。
「NullPointerException」という例外ですね。
（C言語ではエラーにならない場合もあるのです）


さて、JavaのnullはC言語の反省が活かされたデザインになっているのですが、Java言語全体として眺めてみると、少し浮いた存在に感じます。
まずJavaでは、継承関係にない型の値を代入することは禁止されています。
StringクラスとUsagiクラスが継承関係ではないなら、Stringの値をUsagi型の変数に代入することは不可能です（あるいはその逆も不可能です）
ところが、nullはどんなオブジェクト型にも代入可能です。
ではnullは何型なんでしょうか？
（型理論のボトム型と似ていますが、少し違います。）
Javaの言語規定をみると、nullの型は名前を持たないnull型という特殊な型であるとされています。
名前がないため「String s」のように型名を書くことできませんし、null型にキャストすることもできません。
つまり、Javaの型システムから外れたかなり特殊な型として扱われているのです。
これだけならば、言語デザイン上の一貫性の問題ですからあまり実害はないように感じますが
実用的な問題も存在します。
それはJavaのnullエラーをコンパイル時に弾くことができない点です。
このため、nullであるかどうかをプログラマの自身でチェックする必要があります。
C言語のように間違って処理が続行し続けるということはないものの、
このnullチェックは忘れやすい存在でもあります。できればコンパイル時に教えて欲しいと感じてしまいます。

この問題には、2つの対応方法が知られています。
まずはrubyで採用さているアプローチを見てみましょう。
rubyではnullはnilと記述されます。
nilはJavaのような特別な値ではなく、NilClassというクラスのインスタンスです。（ただし、NilClassのインスタンスはnil値だけしか存在しません）
また、rubyは動的型付け言語なので親子関係にない型同士でも変数に代入することができます。
ですので、Javaのようにnullを特別視するのではなく、普通の値として扱うことできます。

rubyでも、nilチェックはプログラマ自身が行う必要がありますが。
rubyの機能を上手く使うことでnullチェックを削除することできます。
例えば配列内の全ての要素を掛け合わせる処理を考えてみましょう。
arr = [1, 2, 3] なら、1*2*3とするような処理です。これはこのように書くことができます。

arr.inject(1){|result, item| result * item } # ->6

このコードはnilを考慮していません。
rubyの配列にはnilが入ることもあるため配列要素中のnilを無視して掛け算を続けるという処理を書く必要があります。
nilチェックそのものは複雑な処理ではないですが、nilはどこでも現れるため、いたるところでnilチェックをする必要がでてきてしまいます。
できればnilチェックなんか書きたくないところです。
というわけで、以下のような方法でnilチェックをさけることができます。

class NilClass
  def to_i
    1
  end
end

arr = [1, 2, nil, 3]
arr.inject(1){|result, item| result * item.to_i }


ここでrubyのオープンクラスという機能を利用してNilClassのto_iメソッドを再定義しています。（NilClassのデフォルトのto_iは0を返します）
to_iメソッドはオブジェクトを整数に変換するメソッドですが、1や2の整数値オブジェクトにto_iを呼んでも結果は変わりません。
nilがくるとto_iによって1に変換されるので、積の計算には影響を与えません。

このようなテクニックをNullオブジェクトパターンと呼びます。
nullにメソッドを追加（上書き）してnullチェックを削除しようというテクニックです。
このようなテクニックはJavaでは不可能ですね。
Javaのnullは特別な値で、メソッドを呼び出すと例外が発生してしまいます。
これに対して、rubyではnilは普通のオブジェクトなのでrubyの普通のテクニックが使えるのです。

さて、rubyとは異なるアプローチも紹介しましょう。
ScalaやHaskellなどで採用されているアプローチで、nullチェックがされているかどうかを型チェックで行うというアプローチです。
ここではScalaを例にみていきましょう。
Scalaでは「nullかもしれない型」というOption型が存在します。

val animals = Map("usagi" -> "u-chan", "hamu" -> "hamu-taro")

def getName(key:String) = animals.get(key) match {
  case Some(name) => name
  case None       => key + " is not found."
}

println(getName("usagi")) # -> u-chan
println(getName("cat")) # -> cat is not found.


このコードではまずanimalsというデータの集合を作り、それに対して名前を取得する getName を定義しています。
コードの詳細はここでは説明しませんが、ポイントは getNameの中身です。
パターンマッチというテクニックを利用しています。
 animals.get(key)　の結果が　「Some(name)」にマッチするなら nameを返し
Noneにマッチするなら「 key + " is not found."」を返す処理です。
このanimals.get(key)の返り値がOption型になっています。
animals.get(key)はnullを返すかもしれないということですね。
で、この結果に対して「Some(name)」にマッチするなら、つまりnullでないなら、名前を返し
None、つまりnullならばエラーメッセージを返すという実装をしています。
こうすると、nullチェックを行っているかどうかを型レベルで保証することが可能になります。
Optionのマッチを一々書くのは少し面倒にも感じますが
コンパイル時にすべてチェックしてくれるというのは大きなメリットです。

nullという普段何気なく使っている機能も、実は色々な試行錯誤の末に発展してきたものなんですね。


（囲み記事：C言語での変数の初期値）
C言語では、初期化されていない変数にも何らかのデータが格納されるようになっています。
例えば以下のコードをみてください

int main(void){
int* arr;
printf("%d\n", arr);
return 0;
}

初期化していないポインタを読みだしていますが、これはエラーにならず何らかの数値を出力します。
どういう値がでるかは状況しだいです。いま、筆者の手元では
「1606422610」
という数値が出力されました。
これではこのarrがまともに初期化された変数なのか、そうでないのかの判断が難しいですね。
このため、明示的にNULLで初期化したりするわけです。
（囲み記事：終わり）


（囲み記事：型でnullがないことを保証する）
あまり一般の言語で採用されていませんが、dependent typeというテクニックを使うとnullが「無い」ことをコンパイル時に保証できます。
これは少し前の記事で紹介しましたね。
簡単に説明すると、dependent typeとは、型名だけではなく中身の値まで型として利用しようという技術です。
例えば「長さが3のint配列」という型や「"A"を含まない文字列」型を作ることができます。
これを使えば、「nullを許可しないString型」というような型を作ることができるのです。
これは型レベルでnullがこないことを保証してくれるので、とても強力です。
ただ、そうすると最初の例でみたような
usagi = rabbits.getByName("ウーちゃん")
という処理で、「ウーちゃん」が見つからなかったら、何を返すべきかという難しい問題が立ち上がります。
一長一短ですね。
（囲み記事：終わり）
