みなさん、こんにちは！
さて、この連載も今回で最後になってしまいました。
最後の記事では非常になじみのある「null」について考え直してみたいと思います。

そもそもnullってなんでしょうか？
おおざっぱに言えば「何もない」ことを表す特別な値です。
多くの言語でnullは存在しますが、実は各言語によってかなり扱い方がことなります。
そこで各言語でのnull扱いを眺めながら、nullとはどういうものだったかを考えてみましょう。

まずはC言語から。
C言語でNULLというと、何も指していない特別なポインタの意味で利用されます。
C言語のポインタはメモリのアドレスを表すため、NULLは無効なメモリアドレスを表すことになります。
アドレスなので、NULLは値を持ちます。またint型の変数としても扱えます（アドレスなので）
以下のようなコードを書いて実際の値を確認することもできます。

#include <stdio.h>

int main(void){
  int i=NULL;
  printf("%d\n",i);
  return 0;
}

ほとんどのCコンパイラではこの値を0としています。
（仕様で0とされているわけではなく、たまたまほとんどのCコンパイラが0にしているだけなので、NULLを0だと思い込むことは危険です）
また、NULLはアドレスを表すので、NULL領域を読み書きすることも可能です。
ただし、動作が保証されない非常に危険なコードになってしまいます。
というわけでC言語ではNULLは「何もない」ことを表すというよりは、「何もないことを表すためのは特別なメモリアドレス」だと覚えても構わないでしょう。

では何故NULLなんてものが必要になるかというと、無効なポインタであることを明示的に示す必要があるからです。
例えばメモリを動的に確保するmallocという関数があります。これは

int* arr = (int*)malloc(sizeof(int)*100);

と呼ぶと、「sizeof(int)*100」の大きさのメモリを確保してくれ、確保したメモリ領域の先頭アドレスを返してくれます。
なので変数arrには確保したメモリ領域の先頭アドレスがはいってるわけです。
問題はこの関数がメモリ確保に失敗したときに、何を返すべきかという点です。
ここでNULLが登場します。mallocはメモリ確保に失敗したときにNULL値を返すようになっているのです。

また、ポインタの初期値されることもあります。C言語では、初期化されていないポインタにアクセスすることが可能です。
そして、ここがC言語のやっかいなところですが、初期化されていないポインタも、なんらかの値が入っているのです。
例えば以下のコードをみてください

int main(void){
int* arr;
printf("%d\n", arr);
return 0;
}

初期化していないポインタを読みだしていますが、これはエラーにならず何らかの数値を出力します。
どういう値がでるかは状況しだいです。いま、筆者の手元では
「1606422610」
という数値が出力されました。
このコードはとても短いので、arrが初期化されておらず不正な値であることはすぐに分かります。
しかし、とてもコードが長くなったりするとどうでしょうか？

int* arr;
...ながいコード...
if( flag ){
  arr = 初期化コード
}
...ながいコード...
printf("%d\n", arr);

となっていた場合、「1606422610」という数値だけを見て、正しく「初期化コード」が実行されたかどうかを判断するのは不可能ですね。
そこで、NULLの登場です。つまり、NULLという特別な値を初期値にしておくことによって、正しく初期化されたかどうかを判定しようという考えです。

int* arr = NULL;
...ながいコード...
if( flag ){
  arr = 初期化コード
}
...ながいコード...
printf("%d\n", arr);

ここでNULL値と同じ値であれば、「初期化コード」がちゃんと実行されていないことが判定できますね。

このようにNULLはエラーになった関数の返り値や、ポインタの初期値として利用されます。


これに対して、Javaでは事情が異なります。まずJavaにはポインタという概念がありません。
ですので、JavaのnullはC言語とはそもそも異なる考え方になります。
何が変わるかというと、Javaではポインタの代わりに参照という考え方を採用しているため
null自体もメモリアドレスを表す物ではなくなっています。
例えば、Javaのnullはintに変換することはできません。

int x = (int)null;

とするとコンパイルエラーがおきます。



（囲み記事：参照とポインタの違い）
参照はポインタと似ていますが、実際のメモリアドレスを表すわけではありません。
具体的なメモリの情報をユーザから隠すために利用されています。
例えば

Usagi usagi = new Usagi('ウーちゃん');

と書くと、「new Usagi('ウーちゃん')」の値がJavaのヒープメモリ上に展開されます。
この値（オブジェクト）にアクセスするためには、実際のメモリアドレスを知る必要があるのですが、
Javaではメモリアドレスは隠蔽されますので、ユーザはこのオブジェクトのアドレスを知ることができません。
では、どうするのかというと、メモリアドレスをユーザに渡す代わりに
メモリアドレスの代替となる情報をユーザに渡します。それが参照です。
イメージ的には、ヒープ上のデータにアクセスするには、参照情報をJVMに渡して、アクセスを依頼します。
すると、JVMは参照から実際のメモリアドレスを計算して、オブジェクトにアクセスするという手順を踏むのです。
例えば

System.out.println(usagi.name);

のようにusagi.nameとアクセスすると、usagiが表す参照値からメモリアドレスに変換され、そこからnameデータを取得するという流れになります。

つまり、C言語のポインタがメモリのアドレスを直接示していたのに対して
Javaの参照は、JVMがメモリアドレスに変換できる特別な値になります。

この参照の概念のメリットは「特定のハードに依存させないため」と「GCのため（メモリ管理のため）」の2つがあげられます。
ポインタのように実際のアドレスを知ってしまうと、特定のハードでしか動かないコードを書いてしまう可能性があります。
例えば、「XXXというハードのメモリサイズはいくつだから、ここまでのポインタ値が使えるな」というように考えてコードを書いてしまうかもしれません。
これでは他のマシンで動かない可能性がありますね。
また、GCではメモリの空き領域を確保するために、オブジェクトを並べなおします。つまり、GCによってオブジェクトのアドレスが変更されるのです。
このような変化する値をユーザに見せてしまうと混乱の元になります。



